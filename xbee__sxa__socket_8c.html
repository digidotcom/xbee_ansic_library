<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Digi XBee(R) ANSI C Host Library: ports/rabbit/xbee_sxa_socket.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Digi XBee(R) ANSI C Host Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_01538ad46ba247002bef53366126b333.html">ports</a></li><li class="navelem"><a class="el" href="dir_fb29ac2b1397a107b3ce66c99f9d856f.html">rabbit</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xbee_sxa_socket.c File Reference<div class="ingroups"><a class="el" href="group__xbee.html">XBee Interface</a> &raquo; <a class="el" href="group__xbee__sxa.html">Simplified XBee API (deprecated/unmaintained)</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Simple XBee API, TCP sockets over ZigBee.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="xbee_2platform_8h_source.html">xbee/platform.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="byteorder_8h_source.html">xbee/byteorder.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sxa_8h_source.html">xbee/sxa.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga04cec5760ca52362801366f825805a0f"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>_sxa_socket_tx_handler</b> (struct LoopbackHandler __far *lh, ll_Gather *g)</td></tr>
<tr class="separator:ga04cec5760ca52362801366f825805a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad08c29c9cffd4775a178909a52d93121"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>_sxa_socket_rx_handler</b> (const <a class="el" href="structwpan__envelope__t.html">wpan_envelope_t</a> <a class="el" href="group__hal.html#gaef060b3456fdcc093a7210a762d5f2ed">FAR</a> *envelope, <a class="el" href="structwpan__ep__state__t.html">wpan_ep_state_t</a> <a class="el" href="group__hal.html#gaef060b3456fdcc093a7210a762d5f2ed">FAR</a> *ep_state)</td></tr>
<tr class="separator:gad08c29c9cffd4775a178909a52d93121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacbb5ad05beda82f9f21740433c7d3f9"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>sxa_socket_init</b> (void)</td></tr>
<tr class="separator:gaacbb5ad05beda82f9f21740433c7d3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Simple XBee API, TCP sockets over ZigBee. </p>
<p>An additional layer of functions for the Rabbit/Dynamic C platform. Implements reliable stream-based transport using the Rabbit TCP/IP socket API. The TCP protocol is transformed in order to run between ZigBee endpoints. This relies on custom loopback interface functionality in the Rabbit TCP/IP stack.</p>
<p>How it works:</p>
<p>For an actively opened connection, the socket is opened to 127.1.0.x (where x is the SXA node table index of the desired peer device). Source and destination ports must currently be in the range 61616 to 61871 inclusive, since the port numbers (src and dest) must be packed into a 16-bit field. The field used is the cluster ID, since cluster IDs are otherwise irrelevant for this endpoint.</p>
<p>For a passively opened connection (i.e. listen), port 61616 is opened. Since the socket will receive connections from any interface by default, if you want it to only accept connections over ZigBee, specify the specific interface IF_LOOPBACK when opening it.</p>
<p>As with any other TCP socket, you can use tcp_reserveport(61616) in order to allow queueing of multiple sessions (from distinct peer devices). (Note: you can use other ports as well for listening, up to 61871).</p>
<p>Given a special loopback device packet handler registered with the normal loopback device driver, TCP segments sent to the above address get intercepted and modified to remove most of the 40 odd bytes of IP and TCP header, since this is not required and wasteful given the small MTU of the ZigBee link. The only field in the IP header which is relevant is the destination IP address, which basically indexes the appropriate destination node.</p>
<p>The TCP header is condensed as follows: seqnum: 16 bits acknum: 16 bits flags: 4 bits window: 12 bits These 6 octets become the condensed TCP header in the ZigBee payload for the endpoint.</p>
<p>Sequence numbers are shortened from the normal 32 bits, by assuming that the peers keep track of the implied 16 MSBs. Since no more than a few hundred bytes in the stream could be outstanding on the network, the seq and ack numbers cannot change very much and hence the additional MSBs to make up the full 32-bit seq numbers can be implied. For safety with this truncation scheme, all socket buffers must be 32k or less. Note that the MSBs of the sequence number are supplied in the initial SYN segment, which transports the entire normal TCP header. In order to obviate the need for this level of driver to maintain the high part of the sequence numbers, the TCP socket handler (TCP.LIB) maintains the necessary state information. TCP assumes that truncated sequence numbers are used if the non-standard tcp_FlagTRUNC flag is set in the TCP header. This bit is set by the lower level driver.</p>
<p>Flags supports only SYN,FIN,ACK and RST. Push and URG are not used. RST (if it appears) must be alone or with ACK in order to have its usual TCP meaning. SYN+RST and FIN+RST are reserved for special use like path MTU discovery (TBD).</p>
<p>When the SYN flag is set, no data payload is attached, but the original (uncondensed) TCP header is supplied as the payload.</p>
<p>Window encodes the actual window: when the MSB is zero, the remaining bits encode the window directly, from 0 to 2047 bytes. When the MSB is 1, the LSBs (in the range 1..2047) encode a multiple of 16 bytes in the window (hence encode window 2048..32752). Windows larger than this encode as 100000000000b. When encoding from the true 16-bit window size, the next lower encodable value is used.</p>
<p>When SYN flag is set, no data is allowed, but the full original TCP header is supplied. In particular, the TCP options are parsed just like "real" TCP, although currently the Rabbit only uses the MSS. MSS is used symmetrically, as the minimum of both side's MSS option.</p>
<p>When reconstructing the IP and TCP headers for incoming segments, the library sets the source IP address to a suitable value depending on the peer node e.g. 127.1.0.5 if received from SXA node 5 (in its local node table). The dest IP address is set to 127.1.0.0. All other fields are reconstructed in a reasonable manner, except that IP and TCP checksums are not generated. It is assumed to be superflous given the ZigBee frame CRCs.</p>
<p>Determining the path MTU can be tricky. For now, it is set to 104 octets, (default definition of SXA_SOCKET_MTU, which can be overridden), but with IP and TCP header compression, this results in a TCP MSS of 64 octets. Better throughput may be obtained by experimentation. It is imperative with TCP to avoid fragmentation at lower layers.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000038">Todo:</a></b></dt><dd>Need a better path MTU discovery mechanism.</dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Nov 21 2020 22:08:40 for Digi XBee(R) ANSI C Host Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
